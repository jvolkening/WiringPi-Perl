# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

package WiringPi;
use base qw(Exporter);
use base qw(DynaLoader);
package WiringPic;
bootstrap WiringPi;
package WiringPi;
@EXPORT = qw();

# ---------- BASE METHODS -------------

package WiringPi;

sub TIEHASH {
    my ($classname,$obj) = @_;
    return bless $obj, $classname;
}

sub CLEAR { }

sub FIRSTKEY { }

sub NEXTKEY { }

sub FETCH {
    my ($self,$field) = @_;
    my $member_func = "swig_${field}_get";
    $self->$member_func();
}

sub STORE {
    my ($self,$field,$newval) = @_;
    my $member_func = "swig_${field}_set";
    $self->$member_func($newval);
}

sub this {
    my $ptr = shift;
    return tied(%$ptr);
}


# ------- FUNCTION WRAPPERS --------

package WiringPi;

*wiringPiSetupPerl = *WiringPic::wiringPiSetupPerl;
*wiringPiSetupSysPerl = *WiringPic::wiringPiSetupSysPerl;
*wiringPiSetupGpioPerl = *WiringPic::wiringPiSetupGpioPerl;
*pullUpDnControl = *WiringPic::pullUpDnControl;
*pinMode = *WiringPic::pinMode;
*digitalWrite = *WiringPic::digitalWrite;
*pwmWrite = *WiringPic::pwmWrite;
*pwmSetMode = *WiringPic::pwmSetMode;
*pwmSetRange = *WiringPic::pwmSetRange;
*pwmSetClock = *WiringPic::pwmSetClock;
*digitalRead = *WiringPic::digitalRead;
*shiftOut = *WiringPic::shiftOut;
*shiftIn = *WiringPic::shiftIn;
*delay = *WiringPic::delay;
*delayMicroseconds = *WiringPic::delayMicroseconds;
*millis = *WiringPic::millis;
*serialOpen = *WiringPic::serialOpen;
*serialClose = *WiringPic::serialClose;
*serialPutchar = *WiringPic::serialPutchar;
*serialPuts = *WiringPic::serialPuts;
*serialDataAvail = *WiringPic::serialDataAvail;
*serialGetchar = *WiringPic::serialGetchar;
*serialPrintf = *WiringPic::serialPrintf;
*softPwmCreate = *WiringPic::softPwmCreate;
*softPwmWrite = *WiringPic::softPwmWrite;
*wiringPiSPISetup = *WiringPic::wiringPiSPISetup;
*wiringPiSPIDataRW = *WiringPic::wiringPiSPIDataRW;
*piHiPri = *WiringPic::piHiPri;
*wpiPinToGpio = *WiringPic::wpiPinToGpio;
*physPinToGpio = *WiringPic::physPinToGpio;

# ------- CONSTANT STUBS -------

package WiringPi;

sub INPUT () { $WiringPic::INPUT }
sub OUTPUT () { $WiringPic::OUTPUT }
sub PWM_OUTPUT () { $WiringPic::PWM_OUTPUT }
sub GPIO_CLOCK () { $WiringPic::GPIO_CLOCK }
sub SOFT_PWM_OUTPUT () { $WiringPic::SOFT_PWM_OUTPUT }
sub SOFT_TONE_OUTPUT () { $WiringPic::SOFT_TONE_OUTPUT }
sub PWM_TONE_OUTPUT () { $WiringPic::PWM_TONE_OUTPUT }
sub LOW () { $WiringPic::LOW }
sub HIGH () { $WiringPic::HIGH }
sub PUD_OFF () { $WiringPic::PUD_OFF }
sub PUD_DOWN () { $WiringPic::PUD_DOWN }
sub PUD_UP () { $WiringPic::PUD_UP }
sub PWM_MODE_MS () { $WiringPic::PWM_MODE_MS }
sub PWM_MODE_BAL () { $WiringPic::PWM_MODE_BAL }
sub WPI_MODE_PINS () { $WiringPic::WPI_MODE_PINS }
sub WPI_MODE_GPIO () { $WiringPic::WPI_MODE_GPIO }
sub WPI_MODE_GPIO_SYS () { $WiringPic::WPI_MODE_GPIO_SYS }
sub WPI_MODE_PHYS () { $WiringPic::WPI_MODE_PHYS }
sub WPI_MODE_PIFACE () { $WiringPic::WPI_MODE_PIFACE }
sub WPI_MODE_UNINITIALISED () { $WiringPic::WPI_MODE_UNINITIALISED }
sub INT_EDGE_SETUP () { $WiringPic::INT_EDGE_SETUP }
sub INT_EDGE_FALLING () { $WiringPic::INT_EDGE_FALLING }
sub INT_EDGE_RISING () { $WiringPic::INT_EDGE_RISING }
sub INT_EDGE_BOTH () { $WiringPic::INT_EDGE_BOTH }

# ------- VARIABLE STUBS --------

package WiringPi;



require IO::Select;

our $wiringPiMode;
our @_children;

END {

    for (@_children) {
        kill -9, $_;
        waitpid($_, 0);
    }

}

my @const = qw/
    INPUT
    OUTPUT
    PWM_OUTPUT
    GPIO_CLOCK
    SOFT_PWM_OUTPUT
    SOFT_TONE_OUTPUT
    PWM_TONE_OUTPUT
    LOW
    HIGH
    PUD_OFF
    PUD_DOWN
    PUD_UP
    PWM_MODE_MS
    PWM_MODE_BAL
    WPI_MODE_PINS
    WPI_MODE_GPIO
    WPI_MODE_GPIO_SYS
    WPI_MODE_PHYS
    WPI_MODE_PIFACE
    WPI_MODE_UNINITIALISED
    INT_EDGE_SETUP
    INT_EDGE_FALLING
    INT_EDGE_RISING
    INT_EDGE_BOTH
/; 

my @func = qw/
    wiringPiSetup
    wiringPiSetupSys
    wiringPiSetupGpio
    pullUpDnControl
    pinMode
    digitalWrite
    pwmSetMode
    pwmSetRange
    pwmSetClock
    pwmWrite
    digitalRead
    shiftOut
    shiftIn
    delay
    delayMicroseconds
    millis
    serialOpen
    serialClose
    serialPutchar
    serialPuts
    serialDataAvail
    serialGetchar
    serialPrintf
    softPwmCreate
    softPwmWrite
    wiringPiSPISetup
    wiringPiSPIDataRW
    wiringPiISR
    piHiPri
/;

@EXPORT_OK = (@const, @func);
%EXPORT_TAGS = (
 'constants' => [ @const ],
 'functions' => [ @func  ],
 'all'       => [ @const, @func ],
);

# This is done in pure Perl but uses the same sysfs-based mechanism as the C
# libs

sub wiringPiISR {

    my ($pin, $edge, $cb) = @_;

    $pin = $WiringPi::wiringPiMode == WPI_MODE_PINS ? wpiPinToGpio($pin)
         : $WiringPi::wiringPiMode == WPI_MODE_PHYS ? physPinToGpio($pin)
         : $WiringPi::wiringPiMode == WPI_MODE_GPIO ? $pin
         : die "Failed to determine pin mode";
         

    $edge = $edge == INT_EDGE_RISING  ? 'rising'
          : $edge == INT_EDGE_FALLING ? 'falling'
          : $edge == INT_EDGE_BOTH    ? 'both'
          : return();

    my $ret = system("gpio edge $pin $edge");
    die "gpio command failed: check that the binary is installed"
        if ($ret);

    my $fn = "/sys/class/gpio/gpio$pin/value";
    die "pin not set for interrupt" if (! -e $fn);

    my $pid = fork;
    if ($pid) {
        push @_children, $pid;
        return;
    }

    piHiPri(10);
    open my $in, '<', $fn or die "Error opening sysfs: $!\n";

    # this is necessary to prevent early firing
    my $val = <$in>;
    seek $in, 0, 0;

    my $poll = IO::Select->new($in);
    while ($poll->has_exception) {

        # fork again to keep lengthy callbacks from blocking new firings
        if (fork() == 0) {
            $cb->();
            exit;
        }

        # This is necessary to clear the event each time
        my $val = <$in>;
        seek $in, 0, 0;
    }

    waitpid(-1, 0);
    exit;

}

# These are redefined so that we can keep track of the pin mode

sub wiringPiSetup {
    $wiringPiMode = WPI_MODE_PINS;
    wiringPiSetupPerl();
}

sub wiringPiSetupGpio {
    $wiringPiMode = WPI_MODE_GPIO;
    wiringPiSetupGpioPerl();
}

sub wiringPiSetupSys {
    $wiringPiMode = WPI_MODE_PHYS;
    wiringPiSetupSys();
}

1;
